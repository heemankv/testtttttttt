import{disconnect as l,getAccount as h,watchAccount as w,fetchBalance as d,getNetwork as C,watchNetwork as u,switchNetwork as f,fetchEnsName as g,fetchEnsAvatar as m,connect as s,InjectedConnector as p}from"@wagmi/core";import{WalletConnectConnector as I}from"@wagmi/connectors/walletConnect";import{WalletConnectLegacyConnector as y}from"@wagmi/core/connectors/walletConnectLegacy";import{jsonRpcProvider as W}from"@wagmi/core/providers/jsonRpc";class A{constructor(t,n){this.wagmi={},this.walletConnectUri="",this.walletConnectVersion=1,this.chains=[],this.namespace="eip155",this.disconnect=l,this.getAccount=h,this.watchAccount=w,this.fetchBalance=d,this.getNetwork=C,this.watchNetwork=u,this.switchNetwork=f,this.fetchEnsName=g,this.fetchEnsAvatar=m,this.wagmi=t,this.chains=n;const{isV2:e}=this.getWalletConnectConnectors();this.walletConnectVersion=e?2:1}getDefaultConnectorChainId(t){return t.chains[0].id}getWalletConnectConnectors(){const t=this.wagmi.connectors.find(c=>c.id==="walletConnect"),n=this.wagmi.connectors.find(c=>c.id==="walletConnectLegacy"),e=t??n;if(!e)throw new Error("WalletConnectConnector or WalletConnectLegacyConnector is required");return{isV2:!!t,connector:e}}async connectWalletConnectV1(t,n){return new Promise((e,c)=>{t.once("message",async({type:r})=>{if(r==="connecting"){const o=(await t.getProvider()).connector;this.walletConnectUri=o.uri,n(o.uri),o.on("disconnect",()=>{c(Error())}),o.on("connect",()=>{e()})}})})}async connectWalletConnectV2(t,n){const e=await t.getProvider();let c="";return new Promise(r=>{e.once("display_uri",o=>{this.walletConnectUri=o,c=o,n(o)}),e.once("connect",()=>{c===this.walletConnectUri&&r()})})}getDefaultChain(){const t=this.chains.find(n=>n.id===1);return t??this.chains[0]}getConnectorById(t){const n=this.wagmi.connectors.find(e=>e.id===t);if(!n)throw new Error(`Connector for id ${t} was not found`);return n}getConnectors(){return this.wagmi.connectors.filter(t=>!t.id.includes("walletConnect"))}async connectWalletConnect(t,n){const{connector:e,isV2:c}=this.getWalletConnectConnectors(),r=n??this.getDefaultConnectorChainId(e),o=c?this.connectWalletConnectV2.bind(this):this.connectWalletConnectV1.bind(this),[a]=await Promise.all([s({connector:e,chainId:r}),o(e,t)]);return a}async connectConnector(t,n){const e=this.getConnectorById(t),c=n??this.getDefaultConnectorChainId(e);return await s({connector:e,chainId:c})}}const v="eip155";function P({projectId:i}){return W({rpc:t=>{var n;return[1,3,4,5,10,42,56,69,97,100,137,420,42161,42220,43114,80001,421611,421613,1313161554,11297108109].includes(t.id)?{http:`https://rpc.walletconnect.com/v1/?chainId=${v}:${t.id}&projectId=${i}`}:{http:t.rpcUrls.default.http[0],webSocket:(n=t.rpcUrls.default.webSocket)==null?void 0:n[0]}}})}function j({chains:i,version:t,projectId:n}){const e=t===1,c=[new p({chains:i})];return e?c.unshift(new y({chains:i,options:{qrcode:!1}})):c.unshift(new I({chains:i,options:{projectId:n,showQrModal:!1}})),c}export{A as EthereumClient,j as w3mConnectors,P as w3mProvider};
//# sourceMappingURL=index.js.map
